{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "224e23b4-13e9-475e-bee1-18a33ca98e53",
   "metadata": {},
   "outputs": [],
   "source": [
    "#importacion de librerias necesarias\n",
    "\n",
    "import numpy as np #para trabajar con arrays numéricos.\n",
    "import matplotlib.pyplot as plt #para hacer gráficos de entrenamiento como curvas de accuracy y loss\n",
    "from tensorflow.keras.preprocessing.image import ImageDataGenerator #para cargar imágenes desde carpetas y aplicar transformaciones automáticas (como escalado, rotación\n",
    "from tensorflow.keras.models import Sequential #definir un modelo de red neuronal secuencial (capas apiladas una detrás de otra).\n",
    "from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense,BatchNormalization #importa las capas necesarias para construir la CNN\n",
    "from tensorflow.keras.optimizers import Adam  #optimizador que ajusta los pesos del modelo, probamos con Adam primero\n",
    "from sklearn.metrics import classification_report, confusion_matrix #Para evaluar el rendimiento del modelo una vez que ha hecho predicciones\n",
    "from tensorflow.keras.optimizers.experimental import AdamW\n",
    "from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "a11892aa-df93-4ff8-a4ed-4ab8e67a3397",
   "metadata": {},
   "outputs": [],
   "source": [
    "#lECTURA DE NUESTROS DATOS Y FIJAMOS VARIABLES\n",
    "img_size = 48 #definimos una variable para fijar el tamaño (alto y ancho) al que se redimensionarán todas las imágenes antes de pasarlas por la red neurona\n",
    "batch_size = 32 # sacado de la literatura es el número de imágenes que el modelo procesará a la vez antes de actualizar los pesos - un EPOCH o paso de entrenamiento\n",
    "epochs = 30 #cuántas veces el modelo verá todo el dataset completo de entrenamiento - lo usaremos en el .fit\n",
    "ruta_train = r\"C:\\Users\\anaco\\Downloads\\data\\archive\\train\"\n",
    "ruta_test = r\"C:\\Users\\anaco\\Downloads\\data\\archive\\test\"    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "b2df6d93-9cb7-4269-ad96-dd500511f428",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "imagenes de entrenamiento normalizadas: (28709, 48, 48, 1) | etiquetas codificadas: (28709,)\n",
      "imagenes de test normalizadas: (7178, 48, 48, 1)  | etiquetas codificadas para test: (7178,)\n",
      "Clases: ['angry' 'disgust' 'fear' 'happy' 'neutral' 'sad' 'surprise']\n"
     ]
    }
   ],
   "source": [
    "#TRATAMIENTO DE IMAGENES\n",
    "#Leer las imágenes manualmente desde carpetas.\n",
    "\n",
    "#Convertirlas a escala de grises, redimensionarlas a 48x48.\n",
    "\n",
    "#Almacenar las imágenes en X_train, y las etiquetas como números en y_train (nuestras Y van a ser las emociones que queremos predecir, pero en formato numerico).\n",
    "\n",
    "#Normalizar las imágenes a [0, 1].\n",
    "\n",
    "import glob\n",
    "import numpy as np\n",
    "from PIL import Image\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import LabelEncoder\n",
    "\n",
    "# LISTA MANUAL DE ETIQUETAS (según nuestras carpetas)\n",
    "etiquetas = ['angry', 'disgust', 'fear', 'happy', 'neutral', 'sad', 'surprise']\n",
    "\n",
    "# Creamos una función para cargar imágenes desde una ruta base, porque tendremos que aplicar esto a nuestras fotos de train y fotos de test\n",
    "def cargar_imagenes_y_etiquetas(ruta_base, etiquetas, img_size):\n",
    "    X = []\n",
    "    y = []\n",
    "    for etiqueta in etiquetas:\n",
    "        ruta_carpeta = fr\"{ruta_base}\\{etiqueta}\\*.jpg\"\n",
    "        for ruta_imagen in glob.glob(ruta_carpeta):\n",
    "            try:\n",
    "                img = Image.open(ruta_imagen).convert(\"L\").resize((img_size, img_size))\n",
    "                X.append(np.array(img))\n",
    "                y.append(etiqueta)\n",
    "            except Exception as e:\n",
    "                print(f\"Error en {ruta_imagen}: {e}\")\n",
    "    X = np.array(X).reshape(-1, img_size, img_size, 1).astype(\"float32\") / 255.0\n",
    "    y = np.array(y)\n",
    "    return X, y\n",
    "\n",
    "# Cargar TRAIN\n",
    "X_train, y_train_raw = cargar_imagenes_y_etiquetas(ruta_train, etiquetas, img_size)\n",
    "\n",
    "# Cargar TEST\n",
    "X_test, y_test_raw = cargar_imagenes_y_etiquetas(ruta_test, etiquetas, img_size)\n",
    "\n",
    "# Codificar etiquetas en números\n",
    "le = LabelEncoder()\n",
    "y_train = le.fit_transform(y_train_raw)\n",
    "y_test = le.transform(y_test_raw)  # usar el mismo encoder\n",
    "\n",
    "# Confirmar formas y carga correcta de datos\n",
    "print(f\"imagenes de entrenamiento normalizadas: {X_train.shape} | etiquetas codificadas: {y_train.shape}\")\n",
    "print(f\"imagenes de test normalizadas: {X_test.shape}  | etiquetas codificadas para test: {y_test.shape}\")\n",
    "print(\"Clases:\", le.classes_)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "31d62d70-5ded-4be4-afff-72f7030745d2",
   "metadata": {},
   "source": [
    "Conclusion: con esos resultados confirmamos que la carga y preprocesamiento del dataset fue un éxito total"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9dafba0f-3424-4861-9631-1306d63d8f9e",
   "metadata": {},
   "source": [
    "Por curiosidad y totalmente opcional \n",
    "vamos a visualizar una imagen normal vs normalizada. \n",
    "Visualmente ambas imágenes se ven igual, porque el ojo no distingue \n",
    "entre escala [0–255] y [0–1] si el contraste relativo es el mismo\n",
    "Pero internamente, los valores de la imagen normalizada están entre 0 y 1, \n",
    "y eso es clave para el entrenamiento del modelo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "72d5ea76-5737-4ab1-a8c3-940a65943fc5",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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g2pqahr8CwQAANj78PWbvUirVq2Ulpamr776yrzfihUrlJaWVn8luk779u0D91F31fq7A3VSUpLy8vKatM60tLQGsY2pqamqqqqq//8FCxbomGOOkSQ9/PDDevvtt/X+++9r4sSJkqTKysom7WtXlZWVjcZF5uXlNXo1ftOmTZL+74r9zTffrOTk5Eb/1P1lZ1fTp0/XBRdcoPPPP1+TJ09u0hp/8pOf6IADDtC7774beN+zzjpLkhq9byQSUTQajTmmAABg78UlvL1IYmKihgwZopdfflmrV69u9Hv1q1ev1ocffqgRI0Y0SHRpytdZ6gb39evXx3w9pKamJu6vqezqT3/6k5KTk/XSSy/FDOLf/QrL7mjVqlX9oL6rgw46SDNnzmxwVfuTTz6RJB144IGSpPPPP18nnHBCo9vu1q1bzP9Pnz5d5513ns455xxNmzZtt74qFI1GnbGW372f1HgE5qZNm5SamqqMjIwm7xcAAPiLK/V7mauvvlrRaFQXXXRRgx+irK2t1a9+9StFo1FdffXVobY/ePBgSdKf//znmNv/8pe/qKamJtyiG5GQkKCkpKSYv3hUVlY2+v3xpurevbuWLVvW4PaTTz5Z5eXleu6552Juf+yxx9ShQwcdeuihkqQOHTpowIABjf7JzMysf9yMGTN03nnn6ayzztIjjzyyWwP9u+++q//85z8aOHBg4H0ff/xxSWr0vsuXL/9B/X4AAADQvLhSv5c54ogjNGXKFF122WUaNGiQfv3rX2u//far/+VT7733nqZMmaLDDz881PZ79eqlM888U3fffbcSExN19NFH69NPP9Xdd9+t7OzsJl1hboqRI0fqnnvu0ZgxY3T++eerpKREd911l1JTU0Nvs6ioSDfffHODDP4RI0Zo+PDh+tWvfqWysjJ16dJFM2fO1Msvv6wnn3yyyRn1kvTss8/q3HPPVd++fXXBBRdowYIFMfV+/frVP4c+ffrorLPOUo8ePep/UHby5Mlq166drrrqqvrHPP3005o1a5ZGjhypgoIClZaW6tlnn9Wf/vQnjRs3Tn369InZx86dO7VgwQKde+65YQ4TAADwEEP9XuiSSy7RIYccorvvvltXXHGFSkpKlJubq0GDBulf//qXDjvssLi2P336dLVv316PPvqofv/736tv37565plndNxxxyknJ+d7eQ5HH320/vjHP+rOO+/UqFGjlJ+fr1/+8pdq06ZN6GF1zJgxuuGGGzRnzpwGmfSzZs3SxIkTdf3112vTpk3q3r27Zs6cqTPOOGO39jFnzhzt3LlTCxcubPSXe3311VcqLCyUJPXs2VMPPfSQvvnmG23fvl0dOnTQGWecoeuvvz7m5xv2339/lZaW6pprrlFJSYmSk5PVq1cv3X///brgggsa7OONN97Qli1b9POf/3y31g4AAPzFb5TF9+Kdd97REUccoaeeekpjxozZ08txGjVqlGpqavT3v/99Ty+l2Zx99tlavny53n777T29FAAA8F/CUI/d9tprr2n+/Pk6+OCD1aJFCy1atEh33HGHsrOz9fHHHzeaMPNDsXjxYvXr10/vvPOOM97SZ8uWLVOPHj00b948DRo0aE8vBwAA/Jfw9RvstqysLL366quaMmWKtm7dqlatWmnEiBG6/fbbf9ADvfRtks306dO1bt26Pb2UZrFq1Srde++9DPQAAPzIcKUeAAAA8ByRlgAAAIDnGOr3YjNmzFBCQoLzzxtvvFF/39tuu63RX+z0xhtvNLjvnvTZZ5/pxhtv1IoVK/b0UgAAAH4wGOp/BKZPn6758+c3+NO/f//6+7iG+v79+ze475702Wef6aabbmKoB4DvqLuQE4lEtHLlygb1oqKi+t+Q7aNx48bVRwLXKSws1Lhx4/6r61ixYoUSEhI0Y8aM73W7y5YtU2pqqubPnx9z+/LlyzV69Gjl5OQoIyNDw4cP18KFC3d7+6tXr9Zll12mo446Sjk5Oc7nsGPHDnXu3FlTpkwJ+UywpzDU/wgceOCBGjhwYIM/WVlZgY/Nyspq8n3R/Hbs2PG9/uZeAHuf6upqXXvttXt6Gf8Vzz//vK677ro9vYzvxZVXXqnhw4fH/C6Z4uJiHXnkkfryyy/1xz/+Uc8884yqqqpUVFSkL774Yre2v3TpUj311FNKSUnR8ccf77xfcnKyrr/+et18880qKSkJ/Xzw38dQDyUkJKiiokKPPfZY/VdzioqKJLm/fjNjxgx169ZNqamp6tGjhx5//PEGV1Fcj3Vd5fjggw904oknKjc3V5FIRP369dMzzzwTs8+6Xxo1ZMiQ+rXWbee1117TT3/6U+27776KRCLq0qWLLrjgAm3cuDH0sVm6dKnGjx+vrl27Ki0tTfn5+Ro1apQ++eSTmPvVPdeZM2dq4sSJ6tChg7KysjRs2LAGH7zRaFS33XabCgoKFIlENGDAAL322msqKiqqP+67bvOJJ57QFVdcofz8fKWmpmrp0qVKSkrS7bff3mC9b731lhISEvTss8+Gfs4A/Hbcccfp6aef1qJFi5p1P5WVlc26/abo16+fOnfuvKeXEbclS5bohRde0CWXXBJz++TJk1VcXKw5c+Zo9OjROv744zVnzhylpqbq+uuv3619DB48WMXFxXrttdd0+eWXm/c988wzlZCQoAcffHC3nwv2HIb6H4Ha2lrV1NTE/Kmtra2vz58/Xy1atNDxxx9f/9Wc+++/37m9GTNmaPz48erRo4eee+45XXvttbrllls0b9680Gt8/fXXdcQRR6i0tFTTpk3Tiy++qL59++r000+vH9pHjhyp2267TZJ033331a915MiRkr79p8vDDjtMDzzwgF599VVdf/31eu+99zRo0CDt2LEjZn+7/sXFsnbtWuXl5emOO+7Qyy+/rPvuu09JSUk69NBDG71Kcs0112jlypV65JFH9NBDD+k///mPRo0aFXO8J06cqIkTJ+q4447Tiy++qAsvvFDnnXeevvzyy0bXcPXVV2vVqlWaNm2aZs+erTZt2ujEE0/UtGnTYrYrSffee686dOigk08+OfC5Adg7XXXVVcrLy9OECRMC71tVVaWrr75anTp1UkpKivLz83XxxRertLQ05n6FhYU64YQTNGvWLPXr10+RSEQ33XRT/cWHp59+WhMmTFD79u2VkZGhUaNGaf369dq6davOP/98tWrVSq1atdL48eNVXl4es+377rtPgwcPVps2bZSenq6DDjpIkyZNavC53Zjvfv2mqKjI+XNkdb2kuLhYF110kXr27KmMjAy1adNGRx99tP75z3822P7atWt12mmnKTMzU9nZ2Tr99NMbjUT+4IMPdMYZZ6iwsFAtWrRQYWGhzjzzzEa/BtWYBx54QO3atdPw4cNjbn/++ed19NFHq6CgoP62rKwsjR49WrNnz96tf7ndZ5+mj3wpKSk6/fTT9dBDD4mQRH+QU/8jMHDgwAa3JSYm1n8YDBw4UPvss49at27d6H13tXPnTk2cOFH9+/fX888/r4SEBEnSoEGD1LVrV3Xo0CHUGi+66CL16tVL8+bNU1LSt6flscceq40bN+qaa67R2LFj1bp1a3Xt2lWS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4v7J/YSEhAbbnDNnjtasWaMuXbrs9vYOPfRQpaam6s9//nNMk3333Xe1cuVK51dwGhOJRHT++efr3nvv1TvvvKO+ffvqiCOO2O01Adg7JSQk6M4779Tw4cP10EMPNajn5eWppqZGxcXFMYN9NBrVunXrdMghhzTY3vfthRdeUEVFhWbNmhXzw6AfffRR6G1+/PHHOumkk3TUUUc1+JqM9O3Fmrrvi+9q69atMf+fl5enBQsWNHj8dy9gbdmyRS+99JJuuOEG/c///E/97dXV1fXDt6XuwtZ379uiRQt16dKlQdqaJH3yySdq0aKF9t9/f0nf9rrvrj9edesJ+nkA/HAw1P8ILF68uNF/guvcuXP9B/lBBx2kN954Q7Nnz1b79u2VmZnZ6NXxffbZR7fccovOO+88nXzyyfrlL3+p0tJS3XjjjQ2uXrRr107Dhg3T7bffrpYtW6qgoEBz587VrFmzGmz3wQcf1IgRI3Tsscdq3Lhxys/P16ZNm7RkyRItXLiw/gdF635xykMPPaTMzExFIhF16tRJ3bt3V+fOnfU///M/9d9BnD17tl577bVGj0lSUpKOOuqoBv+8/F0nnHCCZsyYoe7du6t379768MMPNXnyZO27777m41xyc3N1+eWX1x+Tk08+WatXr9ZNN92k9u3b71Y6gfTtDxhPmjRJH374oR555JFQawKw9xo2bJiGDx+um2++WR07doypDR06tP5nhv7f//t/9bc/99xzqqio0NChQ5t9fY1dkIlGo40O402xatUqjRgxQvvvv7+ee+45JScnN7rP716s+fjjjzV//vyYYzRkyBA988wz+utf/xrzFZynn366wfai0WiDbT7yyCMNEsoaU1BQoBYtWmjZsmUNaieffLKmTJmir7/+un5tW7du1axZs3TiiSfWhyIE/Wt2GMuXL5fU8OcU8MPFUP8jMH78+EZvf/jhh3XeeedJkqZOnaqLL75YZ5xxhrZt26ajjjqqQb58nXPPPVeSdOedd2r06NEqLCzUNddcozfffLPBY5544gldcsklmjBhgmprazVq1CjNnDlTAwYMiLnfkCFDtGDBAt1666267LLLtHnzZuXl5alnz54xP1TaqVMnTZkyRVOnTlVRUZFqa2s1ffp0jRs3TrNnz9ZvfvMbXXDBBUpKStKwYcP0j3/8Q/vtt1+D51BbW9ukD9upU6cqOTlZt99+u8rLy9W/f3/NmjUrrl/scuuttyo9PV3Tpk3T9OnT1b17dz3wwAOaOHHibn+lJz8/X4MGDdLHH3/c6Pc8AeDOO+/UwQcfrA0bNqhXr171tw8fPlzHHnusJkyYoLKyMh1xxBH16Tf9+vXT2Wef3exrGz58uFJSUnTmmWfqqquuUlVVlR544AFt3rw51PZGjBih0tJS3Xvvvfr0009janUXsk444QTdcsstuuGGG3TUUUfpiy++0M0336xOnTrFXAAbO3asfv/732vs2LG69dZb1bVrV/3tb3/TK6+8ErPdrKwsDR48WJMnT1arVq1UWFioN998U48++miTPtNTUlJ02GGH1f8M2K6uvPJKPfHEExo5cqRuvvlmpaam6o477lBVVZVuvPHG3T4+f/nLXyT938D+wQcfKCMjQ5JiftBX+vZfkBMTE2MS4PADFwW+J+ecc060oKBgTy/DS8uXL4+mpKREb7311t163Pr166ORSCT629/+tplWBsAX06dPj0qKvv/++w1qY8aMiUqK9urVK+b2ysrK6IQJE6IFBQXR5OTkaPv27aO/+tWvops3b465X0FBQXTkyJENtvv6669HJUWfffbZJq3lhhtuiEqKFhcX1982e/bsaJ8+faKRSCSan58f/e1vfxv9+9//HpUUff311+vv11iPKSgoiJ5zzjn1/y/J+Wf69OnRaDQara6ujl555ZXR/Pz8aCQSifbv3z/6wgsvNLr91atXR0855ZRoRkZGNDMzM3rKKadE33nnnZjt7Xq/li1bRjMzM6PHHXdcdPHixQ3W5/Loo49GExMTo2vXrm1QW7p0afSkk06KZmVlRdPS0qJDhw6Nfvjhh4HbbIx1fL7ryCOPjI4aNSrUfrBnJESj/FYBfD/GjRunN954I1Ss5Y/JokWLNHPmTB1++OHKysrSF198oUmTJqmsrEyLFy92puDsavXq1Vq+fLkmT56sefPm6csvv1R+fv5/YfUAgO9bVVWV9ttvP11xxRVN+qVhzW3ZsmXq2rWrXnnllQa/EAs/XERaAv9l6enp+uCDD3Tuuedq+PDhmjhxovr166d//etfTRropW+/q1lUVKRPP/1UTz31FAM9AHis7jf03nPPPfW/0GtP+t3vfqehQ4cy0HuGK/UAAAB7WG1trSZNmqQTTjhhj/6yp5qaGt1xxx067bTT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",
      "text/plain": [
       "<Figure size 800x400 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Seleccionamos una imagen (la 5, por ejemplo)\n",
    "imagen_normalizada = X_train[5]\n",
    "etiqueta_codificada = y_train[5]\n",
    "etiqueta_texto = le.inverse_transform([etiqueta_codificada])[0] # usamos .inverse_transform() para convertir de número a texto (por ejemplo, 4 → 'happy').\n",
    "\n",
    "# Para comparación, recreamos la imagen original (des-normalizada)\n",
    "imagen_original = imagen_normalizada * 255\n",
    "\n",
    "# Convertir a 2D para mostrar\n",
    "original_2d = imagen_original.reshape(img_size, img_size)\n",
    "normalizada_2d = imagen_normalizada.reshape(img_size, img_size)\n",
    "\n",
    "# Dibujar graficamente\n",
    "plt.figure(figsize=(8, 4))\n",
    "\n",
    "plt.subplot(1, 2, 1)\n",
    "plt.imshow(original_2d, cmap='gray')\n",
    "plt.title(f\"Original (0–255)\\nEtiqueta: {etiqueta_texto}\")\n",
    "plt.axis(\"off\")\n",
    "\n",
    "plt.subplot(1, 2, 2)\n",
    "plt.imshow(normalizada_2d, cmap='gray')\n",
    "plt.title(\"Normalizada (0–1)\")\n",
    "plt.axis(\"off\")\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "12637b55-0695-4f46-885a-271592564a14",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Creamos ahora un modelo de 4 capas CON2D con aumento progrsivo de neuronas par aun efecto lupa\n",
    "#añadimos tambien batchNormalizacion como en clase\n",
    "\n",
    "\n",
    "# Número de clases\n",
    "num_clases = len(np.unique(y_train))  # 7\n",
    "\n",
    "# Definimos el modelo\n",
    "model = Sequential([\n",
    "    # 1ª capa convolucional\n",
    "    Conv2D(32, (3,3), activation='relu', input_shape=(48, 48, 1)),\n",
    "    BatchNormalization(),\n",
    "    MaxPooling2D(2,2),\n",
    "\n",
    "    # 2ª capa convolucional\n",
    "    Conv2D(64, (3,3), activation='relu'),\n",
    "    BatchNormalization(),\n",
    "    MaxPooling2D(2,2),\n",
    "\n",
    "    # 3ª capa convolucional\n",
    "    Conv2D(128, (3,3), activation='relu'),\n",
    "    BatchNormalization(),\n",
    "    MaxPooling2D(2,2),\n",
    "\n",
    "    # 4ª capa convolucional\n",
    "    Conv2D(256, (3,3), activation='relu'),\n",
    "    BatchNormalization(),\n",
    "    MaxPooling2D(2,2),\n",
    "\n",
    "    # Regularización\n",
    "    Dropout(0.4),\n",
    "\n",
    "    # Clasificación\n",
    "    Flatten(),\n",
    "    Dense(256, activation='relu'),\n",
    "    Dropout(0.6),\n",
    "    Dense(num_clases, activation='softmax')\n",
    "])\n",
    "\n",
    "# Compilamos el modelo con sparse categorical_crossentropy (usamos Adam W ya que vimos en un modelo de HuggingFace que se recomendaba)\n",
    "model.compile(\n",
    "    optimizer=AdamW(learning_rate=0.001, weight_decay=1e-4, epsilon=1e-7),\n",
    "    loss='sparse_categorical_crossentropy',\n",
    "    metrics=['accuracy']\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "9a36a426-1ffa-4a73-8fb0-8f421af91394",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Text(0, 0.5, 'Cantidad de imágenes')"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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t293dVsu8e9//9to37694enpafzlL38xFi5c6OqWahzvKQIAABD3FAEAAEgiFAEAAEgiFAEAAEgiFAEAAEgiFAEAAEgiFAEAAEgiFAHAZe2HH35QYmKiSktLXd0KcNUjFAGodhaLRR988IGr21C3bt20cuVKV7fxh1q2bKnk5ORK4ydPntTdd9+twMBAh980/ve//12zZ8+upg6B2oFQBMAhhYWFmjBhgq6//np5enoqKChId911lz777DNXt2bn448/VmFhoYYOHerqVv5Qbm6uRo8eXWk8Li5OgwcP1gMPPODwNp966ik999xzKikpqYYOgdqB3z4DUGV79uzRLbfcooYNG2rWrFnq2LGjTp06pU8//VTjxo3Td9995+oWTa+88opGjBiha665/P+/X9OmTc87/tprr13yNjt27KiWLVtqxYoVeuSRRy55O0Btcvn/rwWAy8bYsWNlsViUk5Ojv//972rTpo1uuOEGxcfHKzs7+4Lfe/zxx9WmTRt5eXnp+uuv15NPPqlTp06Z6zdv3qzbb79d3t7e8vHxUVhYmL7++mtzfVZWlrp166Z69eopKChIEydO1IkTJy64v19//VVr165VVFSU3bjNZtPo0aPl5+cnHx8f3XHHHdq8ebO5PiEhQZ06ddK//vUvNW/eXA0aNNAjjzyiiooKzZo1SwEBAfLz89Nzzz1nt929e/dq0KBBatCggXx8fBQdHa2DBw/a1Xz00Ufq0qWL6tatqyZNmmjIkCHmunMvn/3R9s72uWzZMrVs2VJWq1VDhw7VsWPH7PYZFRWlt95664LnCYA9QhGAKjly5IjS0tI0btw41a9fv9L6hg0bXvC73t7eWrJkib799lu9/PLLWrRokebMmWOuHzZsmK677jrl5uYqLy9P06ZNk4eHhyRp69at6tu3r4YMGaItW7bo7bffVmZmpsaPH3/B/WVmZsrLy0vt2rUzxwzD0IABA1RYWKhPPvlEeXl5uummm9SzZ08dOXLErNu1a5dWr16ttLQ0vfXWW/rXv/6lAQMGaP/+/crIyNALL7ygJ554wgyBhmFo8ODBOnLkiDIyMpSenq5du3bpnnvuMbf5n//8R0OGDNGAAQO0adMmffbZZ+rSpct5e6/K9s72+cEHH+jjjz/Wxx9/rIyMDD3//PN2NX/961+Vk5OjsrKyC54rAP/DpT9HC+CKsXHjRkOS8f777/9hrSQjNTX1gutnzZplhIWFmZ+9vb2NJUuWnLc2NjbWGD16tN3Y+vXrjWuuucYoLS0973fmzJljXH/99XZjn332meHj42OcPHnSbrxVq1bGggULDMMwjJkzZxpeXl5GSUmJub5v375Gy5YtjYqKCnOsbdu2RlJSkmEYhrFmzRrDzc3N2Lt3r7l++/bthiQjJyfHMAzDiIiIMIYNG3b+k2EYRosWLYw5c+ZUeXvn6/Oxxx4zwsPD7ba7efNmQ5KxZ8+eC+4bwH9xTxGAKjEMQ9KZJ8sc9e677yo5OVk//PCDjh8/rt9//10+Pj7m+vj4eD300ENatmyZevXqpbvvvlutWrWSJOXl5emHH37QihUr7Ho5ffq0du/ebTcbdFZpaanq1q1rN5aXl6fjx4+rcePGlWp37dplfm7ZsqW8vb3Nz/7+/nJzc7O7N8nf319FRUWSpIKCAgUFBSkoKMhcHxoaqoYNG6qgoEA333yz8vPzNWrUqCqdq6ps73x9NmvWzOzprLNPrP32229V2jdQ23H5DECVhISEyGKxqKCgwKHvZWdna+jQoerfv78+/vhjbdq0STNmzFB5eblZk5CQoO3bt2vAgAFat26dQkNDlZqaKkk6ffq0xowZo/z8fHPZvHmzdu7caQanczVp0kTFxcV2Y6dPn1azZs3stpOfn68dO3boscceM+vOXrY7y2KxnHfs9OnTks4EtPMFxf8dd+Rx+qps70J9nu3prLOXBS90IzcAe8wUAagSX19f9e3bV6+++qomTpxY6b6io0ePnve+oq+++kotWrTQjBkzzLGffvqpUl2bNm3Upk0bTZo0Sffee6/eeOMN/e1vf9NNN92k7du3q3Xr1lXutXPnziosLFRxcbEaNWokSbrppptUWFgod3d3tWzZssrb+iOhoaHau3ev9u3bZ87ufPvtt7LZbOYsVseOHfXZZ59pxIgR1bK9qtq2bZuuu+46NWnSxMGjAmonZooAVNm8efNUUVGhv/71r3rvvfe0c+dOFRQU6JVXXlFERMR5v9O6dWvt3btXq1at0q5du/TKK6+Ys0DSmctX48eP1xdffKGffvpJX331lXJzc80A8Pjjj2vDhg0aN26c8vPztXPnTn300UeaMGHCBfvs3LmzmjZtqq+++soc69WrlyIiIjR48GB9+umn2rNnj7KysvTEE0/YPenmqF69eqljx44aNmyYvvnmG+Xk5Oj+++9X9+7dzZupZ86cqbfeekszZ85UQUGBtm7dqlmzZl3y9qpq/fr16tOnzyUfG1DbEIoAVFlwcLC++eYb3X777Zo8ebLat2+v3r1767PPPtP8+fPP+51BgwZp0qRJGj9+vDp16qSsrCw9+eST5no3NzcdPnxY999/v9q0aaPo6Gj1799fTz/9tKQzsywZGRnauXOnbrvtNnXu3FlPPvmkmjVrdsE+3dzc9OCDD9rdh2SxWPTJJ5+oW7duevDBB9WmTRsNHTpUe/bskb+//yWfk7Nv727UqJG6deumXr166frrr9fbb79t1vTo0UPvvPOOPvroI3Xq1El33HGHNm7ceMnbq4qTJ08qNTW1yvcyAZAsxtm7JwHgKnLw4EHdcMMNysvLU4sWLVzdjtO9+uqr+vDDD7VmzRpXtwJcMZgpAnBV8vf31+LFi7V3715Xt+ISHh4emjt3rqvbAK4ozBQBAACImSIAAABJhCIAAABJhCIAAABJhCIAAABJhCIAAABJhCIAAABJhCIAAABJhCIAAABJhCIAAABJhCIAAABJ0v8HNuutZzdzw8oAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "#revisamos el desbalance de clases \n",
    "classes, counts = np.unique(y_train, return_counts=True)\n",
    "plt.bar(classes, counts)\n",
    "plt.xlabel(\"Clase (emoción)\")\n",
    "plt.ylabel(\"Cantidad de imágenes\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6b69292b-a2a7-4b71-a1a3-9ac52067a2d6",
   "metadata": {},
   "source": [
    "Ya hemos visto que nuestras clases estan desbalanceadas. Vamos a aplicar tecnicas de data augmentation en la parte del codigo de abajo\n",
    "\n",
    "Primero: Detectamos qué clases tienen menos imágenes.\n",
    "\n",
    "Segundo: Creamos nuevas imágenes para esas clases, aplicando transformaciones visuales (data augmentation).\n",
    "\n",
    "Tercero: Mezclamos esas nuevas imágenes que hemos creado con las originales.\n",
    "\n",
    "Luego entrenamos la red neuronal con un conjunto mas equilibrado comparando los resultados con el modelo anterior sin DA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "0acbbcc9-d48f-4ff1-8b88-f4a8d5c09eae",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Conteo de clases tras data augmentation: Counter({0: 7215, 1: 7215, 2: 7215, 3: 7215, 4: 7215, 5: 7215, 6: 7215})\n"
     ]
    }
   ],
   "source": [
    "from collections import Counter #en la literatura hemos encontrado esta funcion que nos permite contar cuántas imágenes hay por clase.\n",
    "from tensorflow.keras.preprocessing.image import ImageDataGenerator #es la funcion de Keras que aplica transformaciones a las imágenes para crear versiones nuevas.\n",
    "\n",
    "# Contamos cuántas imágenes hay por clase\n",
    "conteo_clases = Counter(y_train)\n",
    "max_count = max(conteo_clases.values()) #obtenemos el número de la clase mayoritaria (max_count).\n",
    "#Esto nos sirve para saber cuántas imágenes debemos generar para igualar las clases minoritarias, y lo guardamos en una variable que usaremos cuando aumentemos las clases.\n",
    "\n",
    "# Crear generador de augmentación, configurandolo con las modificaciones que queremos hacer a las imagenes creadas\n",
    "datagen = ImageDataGenerator(\n",
    "    rotation_range=15, #Rota aleatoriamente la imagen entre -15 y +15 grados\n",
    "    width_shift_range=0.05,  # Desplaza horizontalmente la imagen hasta un 5% del ancho\n",
    "    height_shift_range=0.05, # Desplaza verticalmente hasta un 5% de la altura\n",
    "    zoom_range=0.1, # Hace zoom aleatorio dentro del 90%-110% del tamaño\n",
    "    horizontal_flip=True,# Invierte 180 grados la imagen (efecto espejo)\n",
    "    fill_mode='nearest' # Rellena los píxeles nuevos usando el valor más cercano\n",
    ")\n",
    "\n",
    "# Crear listas para guardar las nuevas imágenes augmentadas\n",
    "X_augmented = []\n",
    "y_augmented = []\n",
    "\n",
    "# Aumentar solo las clases minoritarias\n",
    "for clase, count in conteo_clases.items():\n",
    "    if count < max_count:\n",
    "        num_to_generate = max_count - count\n",
    "        indices = np.where(y_train == clase)[0]\n",
    "        X_clase = X_train[indices]\n",
    "\n",
    "        for i in range(num_to_generate):\n",
    "            idx = i % len(X_clase)\n",
    "            image = X_clase[idx]\n",
    "            image = np.expand_dims(image, 0)\n",
    "            for batch in datagen.flow(image, batch_size=1):\n",
    "                X_augmented.append(batch[0])\n",
    "                y_augmented.append(clase)\n",
    "                break\n",
    "\n",
    "# Combinar con datos originales\n",
    "X_train = np.concatenate([X_train, np.array(X_augmented)])\n",
    "y_train = np.concatenate([y_train, np.array(y_augmented)])\n",
    "\n",
    "# Confirmar que ahora todas las clases tienen el mismo número de imágenes\n",
    "from collections import Counter\n",
    "print(\"Conteo de clases tras data augmentation:\", Counter(y_train))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "6fc1a04c-9def-40f7-9fe9-4f923adf6ae0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/30\n",
      "1579/1579 [==============================] - ETA: 0s - loss: 1.8088 - accuracy: 0.3132\n",
      "Epoch 1: val_loss improved from inf to 1.55746, saving model to modelo_complejo_data_augm.h5\n",
      "WARNING:tensorflow:HDF5 format does not save weights of `optimizer_experimental.Optimizer`, your optimizer will be recompiled at loading time.\n",
      "1579/1579 [==============================] - 255s 153ms/step - loss: 1.8088 - accuracy: 0.3132 - val_loss: 1.5575 - val_accuracy: 0.3821\n",
      "Epoch 2/30\n",
      "1579/1579 [==============================] - ETA: 0s - loss: 1.1545 - accuracy: 0.5660\n",
      "Epoch 5: val_loss improved from 1.18389 to 1.14853, saving model to modelo_complejo_data_augm.h5\n",
      "WARNING:tensorflow:HDF5 format does not save weights of `optimizer_experimental.Optimizer`, your optimizer will be recompiled at loading time.\n",
      "1579/1579 [==============================] - 246s 156ms/step - loss: 1.1545 - accuracy: 0.5660 - val_loss: 1.1485 - val_accuracy: 0.5603\n",
      "Epoch 6/30\n",
      "1579/1579 [==============================] - ETA: 0s - loss: 1.1026 - accuracy: 0.5873\n",
      "Epoch 6: val_loss did not improve from 1.14853\n",
      "1579/1579 [==============================] - 231s 147ms/step - loss: 1.1026 - accuracy: 0.5873 - val_loss: 1.2778 - val_accuracy: 0.5327\n",
      "Epoch 7/30\n",
      "1579/1579 [==============================] - ETA: 0s - loss: 1.0406 - accuracy: 0.6087\n",
      "Epoch 7: val_loss did not improve from 1.14853\n",
      "1579/1579 [==============================] - 232s 147ms/step - loss: 1.0406 - accuracy: 0.6087 - val_loss: 1.1748 - val_accuracy: 0.5476\n",
      "Epoch 8/30\n",
      "1579/1579 [==============================] - ETA: 0s - loss: 0.9929 - accuracy: 0.6257\n",
      "Epoch 8: val_loss did not improve from 1.14853\n",
      "1579/1579 [==============================] - 248s 157ms/step - loss: 0.9929 - accuracy: 0.6257 - val_loss: 1.1736 - val_accuracy: 0.5639\n",
      "Epoch 9/30\n",
      "1579/1579 [==============================] - ETA: 0s - loss: 0.9470 - accuracy: 0.6433\n",
      "Epoch 9: val_loss did not improve from 1.14853\n",
      "1579/1579 [==============================] - 318s 201ms/step - loss: 0.9470 - accuracy: 0.6433 - val_loss: 1.2600 - val_accuracy: 0.5471\n",
      "Epoch 10/30\n",
      " 570/1579 [=========>....................] - ETA: 6:31 - loss: 0.8769 - accuracy: 0.6715"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[8], line 17\u001b[0m\n\u001b[0;32m      9\u001b[0m checkpoint \u001b[38;5;241m=\u001b[39m ModelCheckpoint(\n\u001b[0;32m     10\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mmodelo_complejo_data_augm.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m     11\u001b[0m     save_best_only\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m,\n\u001b[0;32m     12\u001b[0m     monitor\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mval_loss\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m     13\u001b[0m     verbose\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m1\u001b[39m\n\u001b[0;32m     14\u001b[0m )\n\u001b[0;32m     16\u001b[0m \u001b[38;5;66;03m# Entrenamiento\u001b[39;00m\n\u001b[1;32m---> 17\u001b[0m \u001b[43mmodel\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mfit\u001b[49m\u001b[43m(\u001b[49m\n\u001b[0;32m     18\u001b[0m \u001b[43m    \u001b[49m\u001b[43mX_train\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43my_train\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m     19\u001b[0m \u001b[43m    \u001b[49m\u001b[43mvalidation_data\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mX_test\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43my_test\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m     20\u001b[0m \u001b[43m    \u001b[49m\u001b[43mepochs\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mepochs\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m     21\u001b[0m \u001b[43m    \u001b[49m\u001b[43mbatch_size\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mbatch_size\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m     22\u001b[0m \u001b[43m    \u001b[49m\u001b[43mcallbacks\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43m[\u001b[49m\u001b[43mearly_stop\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mcheckpoint\u001b[49m\u001b[43m]\u001b[49m\n\u001b[0;32m     23\u001b[0m \u001b[43m)\u001b[49m\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\pontia-ml\\lib\\site-packages\\keras\\utils\\traceback_utils.py:65\u001b[0m, in \u001b[0;36mfilter_traceback.<locals>.error_handler\u001b[1;34m(*args, **kwargs)\u001b[0m\n\u001b[0;32m     63\u001b[0m filtered_tb \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[0;32m     64\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m---> 65\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m fn(\u001b[38;5;241m*\u001b[39margs, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs)\n\u001b[0;32m     66\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mException\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m e:\n\u001b[0;32m     67\u001b[0m     filtered_tb \u001b[38;5;241m=\u001b[39m _process_traceback_frames(e\u001b[38;5;241m.\u001b[39m__traceback__)\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\pontia-ml\\lib\\site-packages\\keras\\engine\\training.py:1564\u001b[0m, in \u001b[0;36mModel.fit\u001b[1;34m(self, x, y, batch_size, epochs, verbose, callbacks, validation_split, validation_data, shuffle, class_weight, sample_weight, initial_epoch, steps_per_epoch, validation_steps, validation_batch_size, validation_freq, max_queue_size, workers, use_multiprocessing)\u001b[0m\n\u001b[0;32m   1556\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m tf\u001b[38;5;241m.\u001b[39mprofiler\u001b[38;5;241m.\u001b[39mexperimental\u001b[38;5;241m.\u001b[39mTrace(\n\u001b[0;32m   1557\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mtrain\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m   1558\u001b[0m     epoch_num\u001b[38;5;241m=\u001b[39mepoch,\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   1561\u001b[0m     _r\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m1\u001b[39m,\n\u001b[0;32m   1562\u001b[0m ):\n\u001b[0;32m   1563\u001b[0m     callbacks\u001b[38;5;241m.\u001b[39mon_train_batch_begin(step)\n\u001b[1;32m-> 1564\u001b[0m     tmp_logs \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mtrain_function\u001b[49m\u001b[43m(\u001b[49m\u001b[43miterator\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m   1565\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m data_handler\u001b[38;5;241m.\u001b[39mshould_sync:\n\u001b[0;32m   1566\u001b[0m         context\u001b[38;5;241m.\u001b[39masync_wait()\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\pontia-ml\\lib\\site-packages\\tensorflow\\python\\util\\traceback_utils.py:150\u001b[0m, in \u001b[0;36mfilter_traceback.<locals>.error_handler\u001b[1;34m(*args, **kwargs)\u001b[0m\n\u001b[0;32m    148\u001b[0m filtered_tb \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[0;32m    149\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m--> 150\u001b[0m   \u001b[38;5;28;01mreturn\u001b[39;00m fn(\u001b[38;5;241m*\u001b[39margs, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs)\n\u001b[0;32m    151\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mException\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m e:\n\u001b[0;32m    152\u001b[0m   filtered_tb \u001b[38;5;241m=\u001b[39m _process_traceback_frames(e\u001b[38;5;241m.\u001b[39m__traceback__)\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\pontia-ml\\lib\\site-packages\\tensorflow\\python\\eager\\def_function.py:915\u001b[0m, in \u001b[0;36mFunction.__call__\u001b[1;34m(self, *args, **kwds)\u001b[0m\n\u001b[0;32m    912\u001b[0m compiler \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mxla\u001b[39m\u001b[38;5;124m\"\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_jit_compile \u001b[38;5;28;01melse\u001b[39;00m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mnonXla\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[0;32m    914\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m OptionalXlaContext(\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_jit_compile):\n\u001b[1;32m--> 915\u001b[0m   result \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_call(\u001b[38;5;241m*\u001b[39margs, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[0;32m    917\u001b[0m new_tracing_count \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mexperimental_get_tracing_count()\n\u001b[0;32m    918\u001b[0m without_tracing \u001b[38;5;241m=\u001b[39m (tracing_count \u001b[38;5;241m==\u001b[39m new_tracing_count)\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\pontia-ml\\lib\\site-packages\\tensorflow\\python\\eager\\def_function.py:947\u001b[0m, in \u001b[0;36mFunction._call\u001b[1;34m(self, *args, **kwds)\u001b[0m\n\u001b[0;32m    944\u001b[0m   \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_lock\u001b[38;5;241m.\u001b[39mrelease()\n\u001b[0;32m    945\u001b[0m   \u001b[38;5;66;03m# In this case we have created variables on the first call, so we run the\u001b[39;00m\n\u001b[0;32m    946\u001b[0m   \u001b[38;5;66;03m# defunned version which is guaranteed to never create variables.\u001b[39;00m\n\u001b[1;32m--> 947\u001b[0m   \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_stateless_fn(\u001b[38;5;241m*\u001b[39margs, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)  \u001b[38;5;66;03m# pylint: disable=not-callable\u001b[39;00m\n\u001b[0;32m    948\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_stateful_fn \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m    949\u001b[0m   \u001b[38;5;66;03m# Release the lock early so that multiple threads can perform the call\u001b[39;00m\n\u001b[0;32m    950\u001b[0m   \u001b[38;5;66;03m# in parallel.\u001b[39;00m\n\u001b[0;32m    951\u001b[0m   \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_lock\u001b[38;5;241m.\u001b[39mrelease()\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\pontia-ml\\lib\\site-packages\\tensorflow\\python\\eager\\function.py:2496\u001b[0m, in \u001b[0;36mFunction.__call__\u001b[1;34m(self, *args, **kwargs)\u001b[0m\n\u001b[0;32m   2493\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_lock:\n\u001b[0;32m   2494\u001b[0m   (graph_function,\n\u001b[0;32m   2495\u001b[0m    filtered_flat_args) \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_maybe_define_function(args, kwargs)\n\u001b[1;32m-> 2496\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mgraph_function\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_call_flat\u001b[49m\u001b[43m(\u001b[49m\n\u001b[0;32m   2497\u001b[0m \u001b[43m    \u001b[49m\u001b[43mfiltered_flat_args\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mcaptured_inputs\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mgraph_function\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mcaptured_inputs\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\pontia-ml\\lib\\site-packages\\tensorflow\\python\\eager\\function.py:1862\u001b[0m, in \u001b[0;36mConcreteFunction._call_flat\u001b[1;34m(self, args, captured_inputs, cancellation_manager)\u001b[0m\n\u001b[0;32m   1858\u001b[0m possible_gradient_type \u001b[38;5;241m=\u001b[39m gradients_util\u001b[38;5;241m.\u001b[39mPossibleTapeGradientTypes(args)\n\u001b[0;32m   1859\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m (possible_gradient_type \u001b[38;5;241m==\u001b[39m gradients_util\u001b[38;5;241m.\u001b[39mPOSSIBLE_GRADIENT_TYPES_NONE\n\u001b[0;32m   1860\u001b[0m     \u001b[38;5;129;01mand\u001b[39;00m executing_eagerly):\n\u001b[0;32m   1861\u001b[0m   \u001b[38;5;66;03m# No tape is watching; skip to running the function.\u001b[39;00m\n\u001b[1;32m-> 1862\u001b[0m   \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_build_call_outputs(\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_inference_function\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mcall\u001b[49m\u001b[43m(\u001b[49m\n\u001b[0;32m   1863\u001b[0m \u001b[43m      \u001b[49m\u001b[43mctx\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mcancellation_manager\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mcancellation_manager\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[0;32m   1864\u001b[0m forward_backward \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_select_forward_and_backward_functions(\n\u001b[0;32m   1865\u001b[0m     args,\n\u001b[0;32m   1866\u001b[0m     possible_gradient_type,\n\u001b[0;32m   1867\u001b[0m     executing_eagerly)\n\u001b[0;32m   1868\u001b[0m forward_function, args_with_tangents \u001b[38;5;241m=\u001b[39m forward_backward\u001b[38;5;241m.\u001b[39mforward()\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\pontia-ml\\lib\\site-packages\\tensorflow\\python\\eager\\function.py:499\u001b[0m, in \u001b[0;36m_EagerDefinedFunction.call\u001b[1;34m(self, ctx, args, cancellation_manager)\u001b[0m\n\u001b[0;32m    497\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m _InterpolateFunctionError(\u001b[38;5;28mself\u001b[39m):\n\u001b[0;32m    498\u001b[0m   \u001b[38;5;28;01mif\u001b[39;00m cancellation_manager \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[1;32m--> 499\u001b[0m     outputs \u001b[38;5;241m=\u001b[39m \u001b[43mexecute\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mexecute\u001b[49m\u001b[43m(\u001b[49m\n\u001b[0;32m    500\u001b[0m \u001b[43m        \u001b[49m\u001b[38;5;28;43mstr\u001b[39;49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43msignature\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mname\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    501\u001b[0m \u001b[43m        \u001b[49m\u001b[43mnum_outputs\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_num_outputs\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    502\u001b[0m \u001b[43m        \u001b[49m\u001b[43minputs\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    503\u001b[0m \u001b[43m        \u001b[49m\u001b[43mattrs\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mattrs\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    504\u001b[0m \u001b[43m        \u001b[49m\u001b[43mctx\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mctx\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m    505\u001b[0m   \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[0;32m    506\u001b[0m     outputs \u001b[38;5;241m=\u001b[39m execute\u001b[38;5;241m.\u001b[39mexecute_with_cancellation(\n\u001b[0;32m    507\u001b[0m         \u001b[38;5;28mstr\u001b[39m(\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39msignature\u001b[38;5;241m.\u001b[39mname),\n\u001b[0;32m    508\u001b[0m         num_outputs\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_num_outputs,\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m    511\u001b[0m         ctx\u001b[38;5;241m=\u001b[39mctx,\n\u001b[0;32m    512\u001b[0m         cancellation_manager\u001b[38;5;241m=\u001b[39mcancellation_manager)\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\pontia-ml\\lib\\site-packages\\tensorflow\\python\\eager\\execute.py:54\u001b[0m, in \u001b[0;36mquick_execute\u001b[1;34m(op_name, num_outputs, inputs, attrs, ctx, name)\u001b[0m\n\u001b[0;32m     52\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[0;32m     53\u001b[0m   ctx\u001b[38;5;241m.\u001b[39mensure_initialized()\n\u001b[1;32m---> 54\u001b[0m   tensors \u001b[38;5;241m=\u001b[39m \u001b[43mpywrap_tfe\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mTFE_Py_Execute\u001b[49m\u001b[43m(\u001b[49m\u001b[43mctx\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_handle\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdevice_name\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mop_name\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m     55\u001b[0m \u001b[43m                                      \u001b[49m\u001b[43minputs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mattrs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnum_outputs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     56\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m core\u001b[38;5;241m.\u001b[39m_NotOkStatusException \u001b[38;5;28;01mas\u001b[39;00m e:\n\u001b[0;32m     57\u001b[0m   \u001b[38;5;28;01mif\u001b[39;00m name \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "# Entrenamos el modelo directamente con y_train e y_test\n",
    "early_stop = EarlyStopping(\n",
    "    monitor='val_loss',\n",
    "    patience=5,\n",
    "    restore_best_weights=True,\n",
    "    verbose=1\n",
    ")\n",
    "\n",
    "checkpoint = ModelCheckpoint(\n",
    "    \"modelo_complejo_data_augm.h5\",\n",
    "    save_best_only=True,\n",
    "    monitor=\"val_loss\",\n",
    "    verbose=1\n",
    ")\n",
    "\n",
    "# Entrenamiento\n",
    "model.fit(\n",
    "    X_train, y_train,\n",
    "    validation_data=(X_test, y_test),\n",
    "    epochs=epochs,\n",
    "    batch_size=batch_size,\n",
    "    callbacks=[early_stop, checkpoint]\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b4f29f9a-50c5-49b8-a353-f794a1cdc9c5",
   "metadata": {},
   "source": [
    "El modelo siguió aprendiendo en entrenamiento, pero perdió capacidad de generalizar en validación después de la epoch 15.\n",
    "\n",
    "Desde epoch 16 en adelante, el modelo memoriza pero ya no mejora, e incluso empeora en val_accuracy y val_loss, sugiriendo un claro overfitting\n",
    "\n",
    "Entonces, aplicaremos un EarlyStopping(patience=3) para que se detenga automáticamente cuando val_loss deje de mejorar."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "42f39a95-255d-418f-b5f8-7e12b18c8b23",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.metrics import classification_report, confusion_matrix\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "# Predicción\n",
    "y_pred_probs = model.predict(X_test)\n",
    "y_pred = y_pred_probs.argmax(axis=1)\n",
    "\n",
    "# Reporte por clase\n",
    "print(\"🔍 Clasification Report:\\n\")\n",
    "print(classification_report(y_test, y_pred, target_names=le.classes_))\n",
    "\n",
    "# Matriz de confusión\n",
    "conf_matrix = confusion_matrix(y_test, y_pred)\n",
    "plt.figure(figsize=(8, 6))\n",
    "sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues',\n",
    "            xticklabels=le.classes_, yticklabels=le.classes_)\n",
    "plt.xlabel(\"Predicción\")\n",
    "plt.ylabel(\"Etiqueta real\")\n",
    "plt.title(\"Matriz de Confusión\")\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7111b99-c340-4c6c-9efc-db2b37cb6eb0",
   "metadata": {},
   "source": [
    "Interpretacion de los resultados:\n",
    "happy es muy dominante → casi todas las clases tienden a confundirse con ella.\n",
    "\n",
    "fear se reparte: mucha confusión con neutral, sad y surprise.\n",
    "\n",
    "sad se confunde muchísimo con neutral (492), pero también con angry.\n",
    "\n",
    "disgust es pequeña y se reparte en múltiples predicciones.\n",
    "\n",
    "La arquitectura de 4 capas + AdamW + BatchNormalization funciona.\n",
    "\n",
    "happy, surprise, neutral están bastante bien.\n",
    "angry, fear, disgust, sad  requieren atención especial para mejorar el modelo\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e48e9f74-32d6-4c27-b2f1-32aa3a9f6471",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python (pontia-ml)",
   "language": "python",
   "name": "pontia-ml"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
